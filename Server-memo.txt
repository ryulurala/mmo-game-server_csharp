[JobQueue #1, #2]

ex) JobQueue 클래스와 인터페이스(Action을 Push)
  public interface IJobQueue
  {
    void Push(Action job);
  }

  public class JobQueue : IJobQueue
  {
    Queue<Action> _jobQueue = new Queue<Action>();
    object _lock = new object();
    bool _flush = false;        // Queue에 쌓인 것을 실행할건지 말건지 정하는 변수

    public void Push(Action job)
    {
      bool flush = false;

      lock (_lock)
      {
        _jobQueue.Enqueue(job);
        if (_flush == false)
            flush = _flush = true;
      }

      if (flush)
        Flush();        // 순차적으로 하나의 쓰레드만 처리
    }
    void Flush()
    {
      while (true)
      {
        Action action = Pop();
        if (action == null)
            return;

        action.Invoke();
      }
    }
    Action Pop()
    {
      lock (_lock)
      {
        if (_jobQueue.Count == 0)
        {
          _flush = false;
          return null;
        }
        return _jobQueue.Dequeue();
      }
    }
  }
- lock을 걸어서 하나의 쓰레드씩 처리될 수 있도록 한다.
- Push()를 인터페이스로 작성하여 각기 다른 일을 Push()할 수 있도록 한다.(주문서에는 여러 가지 음식이 있는 것과 비슷하다)

- 만약 Room이 있을 경우는 다음과 같이 참조 형태로 null 처리의 크래시 발생을 방지한다. 
ex) push()에 대한 것은 참조 변수로 호출
  GameRoom room = Room;   // Room이 null로 되어 크래시 발생을 방지
  room.Push(
      () => room.Leave(this)
  );
  Room = null;

ex) TaskQueue 클래스와 인터페이스 --- 처리할 일들을 정의.
  interface ITask
  {
    void Execute();
  }

  class BroadcastTask : ITask
  {
    GameRoom _room;
    ClientSession _session;
    string _chat;

    BroadcastTask(GameRoom room, ClientSession session, string chat)
    {
      _room = room;
      _session = session;
      _chat = chat;
    }
    public void Execute()
    {
      _room.BroadCast(_session, _chat);
    }
  }

  class TaskQueue
  {
    Queue<ITask> _queue = new Queue<ITask>();
  }
- 람다 문법이 생기기 전에는 클래스로 정의하여 일을 정의하였다.
- 실무 프로젝트에서는 람다 : 클래스 정의 = 7 : 3 비율로 쓰인다.

------------------------------------------------------------------------------------------------------------------------
[패킷 모아보내기]

* 패킷 모아보내기
- 서버 스레드의 병목 현상을 감해준다.
1)엔진단, 2)콘텐츠단 둘 다 구현

ex) pending List를 만들어 계속 모으고 한꺼번에 Broadcast를 한다.
  List<ArraySegment<byte>> _pendingList = new List<ArraySegment<byte>>();

  public void BroadCast(ClientSession session, string chat)
  {
      S_Chat packet = new S_Chat();
      packet.playerId = session.SessionId;
      packet.chat = $"{chat} I am {packet.playerId}";
      ArraySegment<byte> segment = packet.Write();

      _pendingList.Add(segment);     // 바로 뿌리는 것이 아니라 pending 시킨다.
  }
- 실제로는 AI의 행동도 같이 List에 넣고 보낸다.

ex) Send()의 overloading으로 Server의 pending List 처리
  // Overloading
  public void Send(List<ArraySegment<byte>> sendBuffList)       // 언제 할 지 예측 불가
  {
      if (sendBuffList.Count == 0)        // 예외 처리
          return;

      lock (_lock)    // 한 번에 한 쓰레드만 들어올 수 있게 한다.
      {
          foreach (ArraySegment<byte> sendBuff in sendBuffList)
              _sendQueue.Enqueue(sendBuff);       // Queue에만 넣고 스킵할 수도 있다.

          if (_pendingList.Count == 0)  // 쓰레드 1빠로 send() 호출(전송까지 할 수 있다)
          {
              RegisterSend();
          }
      }
  }

------------------------------------------------------------------------------------------------------------------------
[JobTimer]

* Server의 추가적인 일
- log를 파일로 기록
- crash가 났을 경우, crash dump를 기록

* 중앙 관리 시스템(메인 쓰레드)
1) Tick으로 여러 일 처리
- 시작할 시간이 아니더라도 if 문을 전부 돌아야 하기 때문에 비효율
ex) 
  int roomTick = 0;
  // ...Tick
  // ...Tick
  // ...Tick
  // ...Tick
  // ...Tick
  // ...Tick
  while (true)
  {
      int now = System.Environment.TickCount;
      if (roomTick < now)
      {
          Room.Push(() => Room.Flush());
          roomTick = now + 250;
      }
      // TODO

      // TODO

      // TODO

  }

2) 예약 시스템
- 우선 순위 큐로 구현
ex) Priority Queue template
  public class PriorityQueue<T> where T : IComparable<T>
  {
    List<T> _heap = new List<T>();
    public int Count { get { return _heap.Count; } }

    // O(logN)
    public void Push(T data)
    {
      // 힙의 맨 끝에 새로운 데이터를 삽입
      _heap.Add(data);

      int now = _heap.Count - 1;

      // 도장 깨기를 시작
      while (now > 0)
      {
        // 도장 깨기를 시도
        int next = (now - 1) / 2;
        if (_heap[now].CompareTo(_heap[next]) < 0)
          break;  // 실패

        // 두 값을 교체
        T temp = _heap[now];
        _heap[now] = _heap[next];
        _heap[next] = temp;

        // 검사 위치를 이동
        now = next;
      }
    }
    // O(logN)
    public T Pop()
    {
      // 반환할 데이터를 따로 저장
      T ret = _heap[0];

      // 마지막 데이터를 루트로 이동
      int lastIndex = _heap.Count - 1;
      _heap[0] = _heap[lastIndex];
      _heap.RemoveAt(lastIndex);
      lastIndex--;

      // 역으로 내려가는 도장깨기 시작
      int now = 0;
      while (true)
      {
        int left = 2 * now + 1;
        int right = 2 * now + 2;

        int next = now;

        // 왼쪽 값이 현재 값보다 크면, 왼쪽으로 이동
        if (left <= lastIndex && _heap[next].CompareTo(_heap[left]) < 0)
          next = left;

        // 오른쪽 값이 현재 값(왼쪽 이동 포함)보다 크면, 오른쪽으로 이동
        if (right <= lastIndex && _heap[next].CompareTo(_heap[right]) < 0)
          next = right;

        // 왼쪽, 오른쪽 모두 현재 값보다 작으면 종료
        if (next == now)
          break;

        // 두 값을 교체
        T temp = _heap[now];
        _heap[now] = _heap[next];
        _heap[next] = temp;

        // 검사 위치를 이동
        now = next;
      }
      return ret;
    }

    public T Peek()     // 조회
    {
      if (_heap.Count == 0)
        return default(T);
      return _heap[0];        // 가장 좋은 value
    }
  }

ex) JobTimer class 구현(예약 시스템)
  struct JobTimerElem : IComparable<JobTimerElem>   // job 구조체
  {
    public int execTick;    // 실행 시간
    public Action action;   // 할 Action

    public int CompareTo(JobTimerElem other)
    {
      return other.execTick - execTick;       // Tick이 작은 것이 먼저
    }
  }
  class JobTimer
  {
    PriorityQueue<JobTimerElem> _pq = new PriorityQueue<JobTimerElem>();
    object _lock = new object();

    public static JobTimer Instance { get; } = new JobTimer();

    public void Push(Action action, int tickAfter = 0)  // 몇 tick 후에 action을 시작
    {
      JobTimerElem job;
      job.execTick = System.Environment.TickCount + tickAfter;    // 현재 시간 + 몇 tick 후에
      job.action = action;        // Action 시작

      lock (_lock)
      {
        _pq.Push(job);
      }
    }

    public void Flush()
    {
      while (true)
      {
        int now = System.Environment.TickCount;

        JobTimerElem job;

        lock (_lock)
        {
          if (_pq.Count == 0)
            break;          // while문을 나감

          job = _pq.Peek();       // top() 조회
          if (job.execTick > now)     // 아직이다.
            break;

          _pq.Pop();
        }

        job.action.Invoke();    // 일감을 실행 명령
      }
    }
  }

ex) MainThread 역할
  static void FlushRoom()   // 일감
  {
    Room.Push(() => Room.Flush());
    JobTimer.Instance.Push(FlushRoom, 250);     // 0.25초마다 하도록 예약
  }

  JobTimer.Instance.Push(FlushRoom);      // 예약
  while (true)
  {
    JobTimer.Instance.Flush();
  }

3) [20ms][20ms][...][...]...[]: list로 관리하여 더 효율적인 예약
- (...)안에는 연결 리스트로 돼있다.

------------------------------------------------------------------------------------------------------------------------
[유니티 연동 #1]

* 유니티 제약
- Unity는 Thread가 1 개이므로 Background에서 Thread를 돌리고 Unity object에는 관여할 수 없다.
- DLL을 가져와서 사용할 수 있지만 Debug의 어려움으로 같이 Build하는 방법으로 권장함.
- span 사용 불가 -> Array.Copy(byte[], ...)로 구성한다.

------------------------------------------------------------------------------------------------------------------------
[유니티 연동 #2]

* Unity의 정책
- Unity의 정책에서는 다른 쓰레드로 접근하는 것을 막았다.
- Unity는 메인 쓰레드만 사용한다, 다른 Thread로 Unity Component를 사용할 수 없다(전달은 가능)
- 외부에 PacketQueue.cs를 작성하여 Queue를 Pop할 때마다 Handler를 이용할 수 있도록 한다.

* PacketQueue
- Unity의 정책(only 단일 쓰레드)으로 인해 외부 스크립트에 작성하여 사용한다.
- Unity의 Component를 건드려서는 안된다.

* Func vs Action
- Func: 특정 기능을 수행하면서 return 값을 받을 때 사용, out result를 받는다 = return 값이 있다.
- Action: 특정 기능을 수행할 때 사용
- Predicate는 Func의 일종으로 bool 값을 return 한다

ex) [PacketManager.cs]
  Dictionary<ushort, Func<PacketSession, ArraySegment<byte>, IPacket>> _makeFunc = new Dictionary<ushort, Func<PacketSession, ArraySegment<byte>, IPacket>>();

  public void OnRecvPacket(PacketSession session, ArraySegment<byte> buffer, Action<PacketSession, IPacket> onRecvCallback = null)
  {
    // Deserialization(size, id)
    ushort count = 0;

    ushort size = BitConverter.ToUInt16(buffer.Array, buffer.Offset);
    count += 2;
    ushort id = BitConverter.ToUInt16(buffer.Array, buffer.Offset + count);
    count += 2;

    // Parsing
    Func<PacketSession, ArraySegment<byte>, IPacket> func = null;
    if (_makeFunc.TryGetValue(id, out func))
    {
      // dictionary에서 찾아서 handler를 등록했으면 invoke
      IPacket packet = func.Invoke(session, buffer);
      if (onRecvCallback != null)
        onRecvCallback.Invoke(session, packet);     // Packet Queue(다른 옵션이 있으면)
      else
        HandlePacket(session, packet);      // Default
    }
  }

  
  T MakePacket<T>(PacketSession session, ArraySegment<byte> buffer) where T : IPacket, new()  // Generic으로 넘겨준다.
  {
    T packet = new T();
    packet.Read(buffer);     // Deserialize

    return packet;
  }

- Handler에 대한 수정: OnRecvPacket에 3번 째 매개 변수로 옵션을 주어 invoke 실행 시킨다.
- Func의 리턴 값을 이용

ex) [NetworkManager.cs]
  void Update()
  {
    // 1 Frame에 1 Packet
    IPacket packet = PacketQueue.Instance.Pop();
    if (packet != null)
    {
      PacketManager.Instance.HandlePacket(_session, packet);
    }
  }

  IEnumerator CoSendPacket()
  {
    while (true)
    {
      yield return new WaitForSeconds(3.0f);

      // 3초 후
      C_Chat chatPacket = new C_Chat();
      chatPacket.chat = "Hello Unity !";
      ArraySegment<byte> segment = chatPacket.Write();

      _session.Send(segment);
    }
  }

- Coroutine을 사용하여 Start()에서 실행하고 3초 후 패킷을 보내는 작업을 비동기화 시킨다.
- 시간 지연은 Coroutine을 활용하는 것이 좋다.

------------------------------------------------------------------------------------------------------------------------
[유니티 연동 #3]

* 유니티 연동(방 입장 & 이동)
1) PDL.xml 코드 작성(패킷 자동화)
2) 방 입장 BroadCast 패킷: PlayerId(누가), 디폴트 위치 부여(float x, y, z) ---- Server의 패킷, 각자의 Client가 처리(Handler)
3) 사람 목록 패킷: PlayerList{ PlayerId, isSelf, 위치} ---- Seㄱver의 패킷, 각자의 Client가 처리(Handler)
- isSelf는 List에 내가 포함돼있으므로 나를 판별할 변수
- 경우에 따라서, (isSelf)boolean 방식이 아닌 독립적인 패킷으로 정의해도 된다.

4) 방 퇴장 패킷: 내용 X ---- Client의 패킷, Server가 처리(Handler)
5) 방 퇴장 Broadcast 패킷: PlayerId(누가) ---- Server의 패킷, Client가 처리(Handler)

6) 이동 패킷: posX, posY, posZ ---- Client의 패킷, Server가 처리(Handler)
- Rotation 패킷도 필요하다(자연스러움)
- 자신의 PlayerId를 보내지 않는 이유는 ClientSession에 포함돼있기 때문이다.
- ClientSession에 있는 정보를 분할해야 좋다.(ClientSession은 Client 정보만)
- Unity의 이동 패킷: 자신의 목적지의 위치를 보내준다, 정의 방법 2가지.
a. Primitive type인 float posX, posY, posZ를 정의
b. Vector3를 정의한다(Vector3에 대한 자동화 코드 작성 필수!)

7) 이동 Broadcast 패킷: PlayerId(누가), 위치(x, y, z) ---- Server의 패킷, 각자의 Client가 처리(Handler)

ex) [PDL.xml]
  <?xml version="1.0" encoding="utf-8" ?>
  <PDL>
    <packet name="S_BroadcastEnterGame">      // 2)
      <int name="playerId"/>
      <float name="posX"/>
      <float name="posY"/>
      <float name="posZ"/>
    </packet>
    <packet name="C_LeaveGame">             // 4)
    </packet>
    <packet name="S_BroadcastLeaveGame">      // 5)
      <int name="playerId"/>
    </packet>
    <packet name="S_PlayerList">          // 3)
      <list name="player">
        <bool name="isSelf"/>
        <int name="playerId"/>
        <float name="posX"/>
        <float name="posY"/>
        <float name="posZ"/>
      </list>
    </packet>
    <packet name="C_Move">      // 6)
      <float name="posX"/>
      <float name="posY"/>
      <float name="posZ"/>
    </packet>
    <packet name="S_BroadcastMove">     // 7)
      <int name="playerId"/>
      <float name="posX"/>
      <float name="posY"/>
      <float name="posZ"/>
    </packet>
  </PDL>

------------------------------------------------------------------------------------------------------------------------
[유니티 연동 #4]

* Unity Player 이동 동기화
1) Player(PlayerId 포함), MyPlayer(Player를 상속, 내 움직임 관련) script를 작성 --- 나중에는 PlayerManager로 방에 입장하는 Player들을 추가한다.
ex) [Player.cs]
  public class Player : MonoBehaviour
  {
      public int PlayerId { get; set; }
  }
ex) [MyPlayer.cs]
  public class MyPlayer : Player
  {
    NetworkManager _network;
    // Start is called before the first frame update
    void Start()
    {
      _network = GameObject.Find("NetworkManager").GetComponent<NetworkManager>();        // NetworkManager 오브젝트의 Script 연결
      StartCoroutine("CoSendPacket");
    }

    IEnumerator CoSendPacket()
    {
      while (true)
      {
        // 이동 패킷은 1초에 4번
        yield return new WaitForSeconds(0.25f);

        // 0.25초 후
        C_Move movePacket = new C_Move();
        movePacket.posX = UnityEngine.Random.Range(-50, 50);    // 랜덤값
        movePacket.posY = 0;    // 높이는 0
        movePacket.posZ = UnityEngine.Random.Range(-50, 50);    // 랜덤값

        _network.Send(movePacket.Write());      // ArraySegment를 보내줌
      }
    }
  }
- 이동 패킷은 1초에 4번 정도가 평균이다.
- MyPlayer의 나의 움직임은 NetworkManager에서 send()를 한다

2) Player, MyPlayer를 관리하는 PlayerManager를 만든다.
- Monobehaviour를 상속X, 데이터만 들고있음(컴포넌트 기생X)
- 컴포넌트로 기생하는 것은 Monobehaviour를 상속받는다.

ex) [PlayerManager.cs]
  public class PlayerManager
  {
    MyPlayer _myPlayer;
    Dictionary<int, Player> _players = new Dictionary<int, Player>();

    public static PlayerManager Instance { get; } = new PlayerManager();   // 어디서든 접근할 수 있도록

    public void Add(S_PlayerList packet)
    {
      Object obj = Resources.Load("Player");

      foreach (S_PlayerList.Player p in packet.players)
      {
        GameObject go = Object.Instantiate(obj) as GameObject;
        if (p.isSelf)    // 내가 관리
        {
          MyPlayer myPlayer = go.AddComponent<MyPlayer>();        // MyPlayer Script 첨가
          myPlayer.PlayerId = p.playerId;
          myPlayer.transform.position = new Vector3(p.posX, p.posY, p.posZ);
          _myPlayer = myPlayer;
        }
        else    // 남들이 관리
        {
          Player player = go.AddComponent<Player>();      // Player Script 첨가
          player.transform.position = new Vector3(p.posX, p.posY, p.posZ);
          player.PlayerId = p.playerId;
          _players.Add(p.playerId, player);
        }
      }
    }
    public void Move(S_BroadcastMove packet)
    {
      // 서버 응답이 와서 움직일 수 있다.
      if (_myPlayer.PlayerId == packet.playerId)
      {
        _myPlayer.transform.position = new Vector3(packet.posX, packet.posY, packet.posZ);
      }
      else
      {
        Player player = null;
        if (_players.TryGetValue(packet.playerId, out player))
        {
          // PlayerId를 찾았다.
          player.transform.position = new Vector3(packet.posX, packet.posY, packet.posZ);
        }
      }
    }
    public void EnterGame(S_BroadcastEnterGame packet)
    {
      if (packet.playerId == _myPlayer.PlayerId)
        return;

      Object obj = Resources.Load("Player");
      GameObject go = Object.Instantiate(obj) as GameObject;

      Player player = go.AddComponent<Player>();      // Player Script 첨가
      player.transform.position = new Vector3(packet.posX, packet.posY, packet.posZ);
      _players.Add(packet.playerId, player);
    }
    public void LeaveGame(S_BroadcastLeaveGame packet)
    {
      if (_myPlayer.PlayerId == packet.playerId)
      {
        GameObject.Destroy(_myPlayer.gameObject);
        _myPlayer = null;
      }
      else
      {
        Player player = null;
        if (_players.TryGetValue(packet.playerId, out player))
        {
          // PlayerId를 찾았다.
          GameObject.Destroy(player.gameObject);
          _players.Remove(packet.playerId);
        }
      }
    }
  }
- PlayerList의 Player를 이동시킬 때, 자신도 이동시키는 것을 유의(Handler)
- 순간적인 이동에 대한 것은 부드럽게 lerp로 이동시킨다.
- Handler에서는 함수들을 호출하는 식의 코드를 작성한다.(MonoBehaviour 상속 X)
- Packet Queue는 Broadcast 가능하도록 PopAll()을 구현한다.

ex) PopAll() 함수
  public List<IPacket> PopAll()
  {
    List<IPacket> list = new List<IPacket>();

    lock (_lock)
    {
      while (_packetQueue.Count > 0)
        list.Add(_packetQueue.Dequeue());
    }

    return list;
  }

3) 이동 동기화(2가지 방법)
a. 서버에서 허락 패킷이 왔을 때만 이동 가능 --- ex) LOL
b. 클라이언트에서 이동하고 있다가 서버에서 응답이 오면 보간   --- ex) 배틀그라운드 등의 FPS 게임

------------------------------------------------------------------------------------------------------------------------